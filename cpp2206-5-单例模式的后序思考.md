
# 
在[工程-设计模式-单例模式](./工程-设计模式-单例模式.md)中，我简单的介绍了下单例模式的一些实现。

本文探讨的语言是CPP，不涉及可以自动管理内存的语言，因此可能更细致一些。

在我最近读的一本书，《设计模式沉思录》作者John Vlissides 书中，他谈了一下Singleton，我想因此补充一下我的收获和感悟。我主要谈两点，一是什么时候用单例模式，二是单例模式应该注意哪些点。

# 什么时候用单例模式？
这个看起来咋一看很简单。比如说全局只要一个对象。这个时候我们用单例模式。有一个变形是，如果全局只需要有限个实例，那么也可以用单例模式的变种。我举个例子，比如一个账号密码组合只能登陆一个用户。我们根据账号和密码的组合，在全局中只返回一个该用户。具体的实现方法是，用一个映射表记录账号和密码，以及对应的实例，每次输入账号和密码，如果改实例已经存在，那么返回映射表的对象，否则新建一个。

# 单例模式需要注意的点
## 返回指针还是引用？
为什么要提这个呢？感觉这是一个有趣的问题。返回指针可以更加灵活。  

如果返回指针，万一客户端保存单例指针怎么办？使用单例模式的时候，我们最担心的是，使用单例的代码释放了指针。我们一般的对策是，把析构函数私有化，这样释放指针的时候就会编译失败。  

一般来说，使用单例模式的方法是通过 GetInstance 获得，并且不释放指针，或者引用。更不要把引用对象的地址保存起来，然后强转等骚操作。这样会引起安全问题，如果是恶意代码另说，但是安全的使用方法不应该是如此。  

返回引用有什么好处吗？暂时忘记了。日后再补充。TODO    



## 析构函数是公有还是私有？
析构函数公有还是私有，表明着一个态度，私有说明单例类负责析构，因为我生产，我负责。而公有则希望其他的类帮忙管理这个单例对象。如果是私有，那么应该怎么实现呢？私有析构没法自己删除自己的实例对象，唯一的办法是使用友元。这个友元类类似于一个智能指针。  

如果是公有的话，可以省去这些麻烦，但是切记，其他位置的代码可以随时释放掉这个指针，引发一些安全问题。  

所以，如果使用单例模式是一个规范问题，可能代码层面没法解决。常规使用方法就是，其他处的代码不要保存指针或者引用，只在一个地方析构。  

## 单例对象的生存周期？
一般来说，单例对象的生存周期是一个应用的全生命流程。所以一般会在系统最开始的时候和结束的时候做创建和释放内存的工作。  

单例对象如果彼此互相依赖，那么就要注意析构顺序，被依赖的应该最后被析构，依赖别人的优先析构。 如果是私有构造函数或者全局管理，那么这块应该注意下。  


## 饿汉模式和饱汉模式
不管
这个问题无非是一种经典提法，面试的时候爱问。可能面试官也就知道这个套词了，我平时也没怎么看。但是既然说到了，有必要提一下。  
饿汉模式就是需要时才创建，动态创建的一个过程。而饱汉模式就是在类的一开始就创建好对象。  
本质是时间空间的平衡。  


#  参考
[1]单例模式 冯Jungle
[https://blog.csdn.net/sinat_21107433/article/details/102649056](https://blog.csdn.net/sinat_21107433/article/details/102649056)

[2]C++/Java__中类模板中的静态成员变量和静态成员函数
[https://blog.csdn.net/u010003835/article/details/49104989](https://blog.csdn.net/u010003835/article/details/49104989)

[3]C++中的单例模式
[https://blog.csdn.net/hackbuteer1/article/details/7460019](https://blog.csdn.net/hackbuteer1/article/details/7460019)


[4]设计模式沉思录，作者John Vlissides.  

