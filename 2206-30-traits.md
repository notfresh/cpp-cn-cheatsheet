# 摘要



# 引言

模板技术在C++中是一个新的特性，也是一个比较复杂的特性，而纳入C++标准中STL则是模板技术的一个重要应用。而traits技术则是STL一个比较复杂的技术点。一般的文章、书籍、博客很难把这个技术说清楚，即便在侯捷的 《STL 源码剖析》那本书中，我初次读到关于 traits的就技术介绍的时候，也感觉一头雾水。而在 Scott Mayers著的《Effective C++》第三版条款47中描述的关于traits的技术，刚读起来也是相当的费解，可以说traits技术给人的印象就是，如果你会了，你就可以很轻松的读懂别人关于traits技术的文章，而如果你不会，那么你也很难从别人讲的traits文章里学到一丁点知识。

iterator是为了访问容器内的元素而存在的，而它内置的类型就是通用算法与容器进行沟通的重要工具。而我们使用traits技法主要是为了解决原生指针和自定义iterator之间的不同所造成的代码冗余。说白了就是为了节省代码用的。



迭代器经常是要被当做参数处理的，所以迭代器需要携带原本的类型信息。这一点没有疑问。

其次，不同的容器的迭代器不同，这一点也是没有疑问点。



# traits技术原理

iterator模式定义如下：提供一种方法，使之能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表达形式。

我们在算法中可能会定义简单的中间变量或者设定算法的返回变量类型，这时候需要知道迭代器 iter 所指元素的类型是什么，但是由于没有typeof这类判断类型的函数,我们无法直接获取。总不能老写 `auto x = *iter;`吧！

auto 是省事用的。如果编译器背后没有一套原理可以推断迭代器指代的类型也是不行的。



# traits例子



type_traits的使用，首先用value_type()获取迭代器所指型别T，接着使用`typedef typename __type_traits<T>::is_POD_type is_POD;`获取该迭代器所指对象是否为POD型别，接着使用is_POD()作为函数参数，对应__true_type和__false_type两个重载版本函数。

type_traits.h内声明了所有C++标量型别的特化版本。而如果是我们自己定义的类，使用__type_traits萃取出的都是__false_type（很厉害的那种编译器除外，它可以自己判断是否有trivial函数），即使该类属于POD型别。解决办法是自行设计该类的__type_traits偏特化版本。

如何判断trivial函数？如果class内涵指针成员，就需要实现non-trivial函数。

作者：李素晴
链接：https://juejin.cn/post/6872671849654943758
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 相关工作

摸鱼打字员在他的文章里，详细而清楚的，由浅入深的介绍了traits的原理和价值，是非常有价值的学习traits的资料[1]。

Scott Meyers在他的经典著作 Effective C++第三版条款47中讲述了 traits 技法[2]。他结合STL的迭代器技术和一个算法 advance 的实现过程描述了 traits 的原理，一个traits class 的设计过程和满足条件，以及迭代器的分类等等。

泠渊在他的博客中系统而完整的介绍了C++模板的用法，原理，并且通过形象生动的例子解释了模板的特化和偏特化的技术[3]。他还描述了模板的分离编译问题。

# 参考

[1]摸鱼打字员，C++ STL iterator与traits技法，https://juejin.cn/post/6844903618353561608

[2]Scotter Meyers著，侯捷译，Effective C++（改善程序与设计的55个具体方法） 中文版第三版，条款47，使用traits表现类型信息

[3]泠渊,【带你吃透C++】模板详解,https://juejin.cn/post/7078530622527897631

